# Documentation Landscape (Andrea Ruping)

## Different kinds of content
- Content Ordering: narrative, logical, dramatic
- Decision / Task Oriented
- Intention Revealing


## Segregate asset vs temporary information

Sprint vs System/product
%% insert picture 18/12/2013



## Project Overview

Let's assume that we have a project with source code well organized into packages, layers etc. Its Vision Statement, the Bounded Contexts and their Ubiquitous Language are stored as text files at the root of the project. The relationships between contexts and the possible Anti-corruption layers used could also be described there.

During development many of the programming language elements (interfaces, classes, methods, packages) have been annotated with patterns annotations to declare every pattern (DDD, GoF, Fowler Analysis and PoEAA patterns in particular) that we know are present at the design and architecture levels.

Even the frameworks used may have been also declared using the pattern vocabulary. For example the ORM would be declared as being a Data Mapper.

## Navigation Path

Create a Navigation Path, which is like a journey that goes through the various aspects of the project in a sensible order, with a sense of continuity and of progressive refinement, from the general to the detail.

We can decide to build a path by decreasing priority, such as if you had to stop at any point, you would still have seen the most important so far. Another objective of a navigation path is to walk through the complete project (or at least the most important part), and too avoid duplication.

This navigation path is made of a sequence of Frames. Each frame describes a limited scope of the project. A frame can be a diagram, or a piece of text, or a table.

Each frame has a clear and deliberate perspective on what message it must convey: an Editorial Perspective. For example, a layer diagram is usually used within the editorial perspective of showing the coarse-grain dependencies, rather than within a perspective of data flow.

For each frame, we only Focus on a selection of Elements (programming language elements and patterns on top of them) and on a selection of their Associations. This also means that every other element and association is left out. This selection is dependent on the editorial perspective.
5 - 7 items at a time

Only display or describe no less than 2 and no more than 7 elements at a time, ideally 5-7 items at a time. The issue is that this constraint propagates to every other aspect of navigation path planning!

If for a given frame there are too many items, they must be ranked by decreasing importance, then the 7 first are selected for display, while the other are left for the next frame, and so on until they are all presented, no more than 7 at a time. So far this is just a kind of Pagination. Anyway the next frame must usually reference one or two elements from a previous frame, such as the interface at the top of their type hierarchy, which complicates the pagination a bit.

If there are too many pages, the last pages may be skipped altogether or moved as Addendum or reference, because they may not be of high importance.

On the other hand, to help focusing on 5-7 elements at a time, if a frame does not have much to present (for instance only 2 elements) and if another frame the next frame itself does not contain much (for instance only 4 elements), then we can merge the two frames into one. This Frame Merge can also be done recursively, for instance we could merge 5 frames of only one element into one with 5 elements. A merge can only be done between frames that share a consistent editorial perspective and that describes related elements (e.g. elements with associations between them).

Navigation path planning & Dimensions of navigation

Many navigation paths are possible, along the many dimensions of a software project, each with its distinct editorial perspective and focus:

-  By module or folder containment: Ã  la "Russian Dolls", simply recursively traverse projects and sub-projects, modules and sub-modules, classes and their members. The natural ranking is given by how each scope is nested within another.

-  Specs Vs. Implementation: Present the Vision Statement, Ubiquitous Language and the Business Domains, then describe  to the corresponding modules: this requires the ability to link modules to their context.

-  By contexts map that shows the relationships between contexts, perhaps including strategic design downstream or upstream links, ACL etc.

-  Domain Vs. Cross-cutting concerns: this requires that the patterns definitions or patterns occurrences explicitly declare which domain or concern they address

-  By view (deployment, data flow...); this requires that the patterns definitions (or patterns occurrences) explicitly declare which view is relevant for them

-  By pattern: drill down "architectural" patterns (desktop app, client-server, smart UI, 3-tiers, PoEAA MVC, layers, transaction scripts, table modules, frameworks viewed as arrangements of patterns): this requires either a fixed predefined ordering of the patterns definitions, or a manual configuration of the drill down, or the capability to sort the patterns and their relationships by some sort of topological sort

A navigation path may also interleave several drill-down along various axes, in a similar approach to the breadth-first traversal where we explore several branches in parallel, level by level.
Ranking strategies

When the navigation dimension does not provide a natural ranking of its elements, we can use explicit ranking strategies:

-  By relative importance = level of distillation: rank from Core concepts to Supporting concepts; from highlighted part of the Core Module to other parts

-  By most depended upon: Depended upon first is a good approach that estimates the relative importance of each element, a a similar way to the Page Rank of search engines

-  By frequency of participation in patterns

-  By abstractness: Abstract first; this can be seen as a consequence of sorting most depended upon elements first since super types are more depended upon than concrete classes

-  By topological sort in the graph of patterns, which again is a consequence of "depended upon first" sorting

## The project vs. system confusion

Another thing to clarify is the distinction between a project and a system. A project builds or changes a system. A project starts, stops, has a purpose, a team, stakeholders, and a budget. A system exists, also has a vision, purpose, users and stakeholders, and is made of components or services on top of infrastructures. A system exhibits behaviors and has quality attributes.

> The distinction is the same as the distinction between a balance sheet and a general ledger. The balance sheet describes the overall effect (the system) of all the transactions on the ledger (the projects). At the end of the year, we only care about the balance sheet, not about each individual transaction.

The system and the project only match in the case of the first project whose sole goal is to build a system from scratch. But there are many other situations than this simple case, many systems go through more than one project over their lifetime, and even their death is yet another project.

It is important to sort out precisely the knowledge about the project vs. the knowledge about the system. The knowledge about the project is only useful for the duration of the project, but the knowledge about the system is useful throughout the life of the system.

In general, focus on documenting the knowledge about the system, as the lifetime of the system will far exceed the lifetime of the project. Overall, the system design far outlives the user stories which built it in the first place. After some time, you need to understand the system, and nobody (except auditors) cares how the user stories were split and prioritized.

> ## An Example
>
> Keep all the knowledge about the project planning, teams and management in Jira, and use internal documentation for all the knowledge about the system.
>
> Releases, Iterations and User stories are project artifacts. Use stickers on the wall or a tool like Jira for them. At the time of coding the system, you create key scenarios (or acceptance criteria) and you write the code. These are knowledge about the system, which is best expressed as Internal documentation, in the source control, as automated scenarios (tests) and other means as shown in this book.
>
> Notice that the sentences on the user story: "In order to... As a... I want..." will often end up as the narrative on top of your key scenarios files in the source control. This little duplication ensures that the system owns all its documentation in a standalone fashion. The source code repository is self-documented without the tracker.
