LD - Documenting Legacy


> Software source code is one of the most densely packed forms of communication we have. But, it is still a form of human communication. Refactoring gives us a very powerful tool for improving our understanding of what someone else has written
> -- Chet Hendrickson, Software Archeology: Understanding Large Systems


## Archeology

Especially with legacy, you need a piece of paper and a pen close to your keyboard at all times to take notes and draw.

This is where you create an on-demand map of the terrain for the task at hand. While exploring the code and playing with it at runtime or with the debugger, you write down the inputs, outputs and more generally all the effects you discover. You take note of what's read or written since it will matter for mocking or estimating the impacts. You sketch how each all responsibility depends on its neighbors, a la Effect Map (Michael Feather, Mikado Method).

Of course you may find questions the code does not answer, perhaps the code itself is obscure or surprising, so you need help, ideally from your colleagues nearby, or from a piece of documentation you wish was there otherwise.

It's important to keep the process low-tech so that it does not distract from the task itself. This documentation work is dedicated for the specific task, therefore there is no need to make it clean and formal right now. However when you're done with the task, you may review the notes and sketches and select the one or two key bits of information that are general enough and that would help for many tasks. They can be promoted into a clean diagram, an additional section or an addition within an existing document. Grow your documentation by a decantation.

----------

@KevlinHenney: The universe is made of information, but it doesn't have meaning — meaning is our creation. Searches for meaning are ∴ searches in a mirror.

== lack of structure ==
The biggest issue in legacy code is the big gap between the structure we would expect, clear and relatively simple, and the actual state of the code as a big confused mess.

(Example: football team
Code randomly mixes sorting of players by name
Your mental expectation is to sort them by role or scoring)

Example: code modules by DAO, DTO, Controller... Vs. Billing, Recommendation, Shopping Cart, Catalog.

The mapping between both structures is just a set of a huge number of arbitrary one-to-one relationship.

You can add intrinsic information where they belong: this DTO is part of the billing, this one is part of the Catalog, etc.

This will help prepare the next step: move the classes that deal with Billing into the same Billing module. But even if you don't, your code now has an explicit structure by business domain.

== When you have to do it the soft way ==

It is hard to touch and commit large code bases just to add extra annotations. You don't want to risk introduce random regressions. You don't want to touch commit history. It may be so hard to build that you don't want to build it unless absolutely necessary. Or your boss may refuse you change the code at all "just for documentation".

If it is possible then that's the best way, according to the intrinsic principle.

Otherwise we can do a proof of concept at smaller scale using external annotations combined with parsing the actual source.

== Marginal documentation ==

Focus on the new increments that can live in their own clean bubble context.

Just like architecture and guidelines, the legacy strategy may also be enforced using automated tools. For example you may want to forbid any new commit from having direct references (java import or C# using) on a deprecated component.


--

@mariofusco: A signal that it's time to do some refactoring on your code? That sense of déjà vu while fixing that vaguely familiar bug ...

-> stable teams also address implicit documentation
--

Migration of existing documentation? Gilles: Strangle your specs/documentation! Deprecate / remove + redirect, perhaps with a one-off migration from Word to Markdown so that further maintenance and strangling can be done with just plain test in source control.
