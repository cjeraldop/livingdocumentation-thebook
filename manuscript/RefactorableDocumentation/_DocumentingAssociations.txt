## Annotations on associations

What for? Make the code the model 100%, with no missing or implicit knowledge. For non developers, it also offers the opportunity to render diagrams like we used to do in the 90's, in UML class diagram or something similar, as a support for design conversations. An alternative is to rely on realistic test cases to explain the model by showing how it is typically used. For non developers again, they can also be used to render UML instance diagrams or similar as a support for conversations too. 

// nothing to say
private final Location from;
private final Location to;

When an association is keyed, we use a Map or Dictionary or Hashtable. When the instance is well-named and the key has a no. primitive type, then it is often clear, there is nothing more to say. When it is not the case, for example when the type is not specific enough, then we may have to resort to add a declaration:

@KeyedBy("Buy-Side Counterparty")
private final Map<Couterparty, Exposure> exposure;

There is no need to tell much when types are **also** chosen to express meaning. In the example below, the annotation is redundant with the declared type. It is common knowledge that a `Set` enforces unicity.

~~~~~~~~
@Unicity
private final Set<Currency> currencies;
~~~~~~~~

Similarly the code below does not need the additional ordering declaration, it is implied by the concrete type. But is it really the case from the caller point of view?

~~~~~~~~
@Ordered
Collection<Item> items = new TreeSet<Item>();
~~~~~~~~

For the ordering constraint to become declared by the chosen collection type, we could refactor into:

~~~~~~~~
SortedSet<Item> items = new TreeSet<Item>();
~~~~~~~~

But doing that exposes a lot of methods we may not want to expose. Perhaps we would only like to expose `Iterable<Item>`. If that's the case, perhaps the ordering is an iternal detail.
