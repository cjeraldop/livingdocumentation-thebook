# Test DSL aka DSTL

Pretty Scenario from technical tests

## Example 1: Given-When-Then Test 

One way to structure this DSL is to follow the Given-When-Then template.

A> See Github code from Fabien. and todo: use specific runner for test scenario reporting 

## Example 2: With builders

Using builders it is not  very difficult to create an internal DSL for creating test data. Nat Pryce calls that a Test Data Builder (see ref). (Also see Dave Farley post)

We could extend the previous example with the use of a test data builder to create objects on the given section.

See my github repo. Test data builders can be nested. Les build a bundled travel. We define a bundled travel as a travel that groups flights, accommodation and additional services into one basket so that it's more convenient to buy. We have a test data builder to create each element independently.

aFlight().from("CDG").to("JFK").withReturn().inClass(COACH).build();

anHotelRoom("Radisson Blue").from("12/11/2014").forNights(3).withBreakfast(CONTINENTAL).build();

We have another test data builder to create the bundle from each product.

aBundledTravel("Blue Week-End in NY").with(
aFlight().from("CDG").to("JFK").withReturn().inClass(COACH).build();
).with(
anHotelRoom("Radisson Blue").from("12/11/2014").forNights(3).withBreakfast(CONTINENTAL).build();)
.build();

We can omit the intermediate calls to build()

This becomes: 
aBundledTravel("Blue Week-End in NY").with(...).with(...).build();

It is possible that test data builders are so useful that you decide to use them not just for tests. It happened to me to move them into the production code, making sure they are no longer "test" data builders but just regular companion builders with nothing test-specific in them. 

See also Martin Fowler book on DSL for more elaboration.

## Example 3: Functional event sourcing, test DSL 

When doing event sourcing, all scenarios invariably have the exact same structure: 

given past events, when a new command is applied, then new events are emitted.

Because the structure is always the same, there is no need to tell more than just the past events, the command, and the expected events when coding the scenarios as automated tests. 

Events are named as verbs in the past tense, using nothing but domain vocabulary. Commands are named with imperative verbs, also from the domain language. In this approach, each test is a scenario of the expected business behavior, and there is not much to do to make it a business-readable scenario in fluent English. Back to typical BDD goodness, without Cucumber!

**Therefore: in your Event Sourcing testing framework, for each test, pretty print the events and the command through simple text transformations. 
**





