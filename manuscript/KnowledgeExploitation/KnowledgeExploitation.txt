# Knowledge Exploitation


## Identify authoritative knowledge

Most of the knowledge is already there. For a given project or system, a lot of knowledge is already there and it's everywhere: in the source code of the software, in the various configuration files, in the source code of the tests; in the behavior of the application at runtime, in various random files and as data within the various tools around; and of course in the brain of all the people involved.

Traditional documentation attempts to gather knowledge into convenient documents, in paper form or online. By doing so these documents basically duplicate knowledge that was already present elsewhere. That's obviously a problem when the other document is the authority. It's the one that evolves all the time and that can be trusted.

Because knowledge is already there in many places, all we need is to setup mechanisms to extract the knowledge from where it's located, to bring it where it's needed, when it's needed. And because we're lazy and don't have much time for that, such mechanisms must be lightweight, reliable and low-effort.

I's important to find where's the authoritative knowledge is. When knowledge is repeated at different places we need to know where is the knowledge that we can trust. When decisions change, where does the knowledge reflects the changes most accurately?

**Therefore: identify all the places where authoritative knowledge is located. For a given need, setup mechanisms like automation or process to extract this knowledge and transform it into a adequate form. Make sure this mechanism remains simple and does not become a distraction.**

Knowledge about how the software works is in the source code. In the ideal case, it's easy to read and there is no need for any other documentation. When it's not the case, perhaps because the source code is naturally obfuscated, we just need to make this knowledge more accessible.

## Where is this knowledge now?

Imagine a colleague or manager asking: "Gimme a documentation on stuff X!" The first step to answer that is to ask yourself or the team: "Where is this knowledge now?"

The answer is often obvious: the knowledge is in the code, in the functional tests, or in the document on project goals.

Sometime it's less obvious: the knowledge is in people's brain, or in their head but tacit. It may even be between people, and you'll need collective workshops to elucidate it.

Often at the beginning of projects, the knowledge is genuinely missing. One of the first motivation of the work will be to learn as quickly as possible, in a Deliberate Discovery fashion as Dan North says. Spikes, proofs and concepts and timeboxed work are well-suited for that.

Some knowledge is only tangible during the evaluation of the working software, at runtime.

Once we've found the authoritative knowledge: How can we harness this knowledge to become a living documentation?

When the knowledge is there but in a form that is not accessible or not convenient for the target audience and for the desired purpose, it must be extracted from its **Single Source of Truth** into a more accessible form. This process should be automated to publish a clearly versioned document, with a link to find the latest version.

Sometime the knowledge can't be extracted. For example, the business behavior can't simply be extracted as English business sentences from the code, so we write these sentences by hand as functional scenarios or tests. By doing so we introduce a redundancy in the knowledge, so we need a **Reconciliation Mechanism** to easily detect inconsistencies.

When the knowledge is spread over many places, we need a way to do a **Consolidation** of all the knowledge into one aggregated form. And when there is an excess of knowledge, a careful selection process, i.e. a  **Curation** process is essential.
