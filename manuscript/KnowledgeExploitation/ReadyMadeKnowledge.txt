# Ready-Made Documentation


> ## Software Craftsmanship Apprenticeship Patterns book
>
> Study the Classics - reference them when you use their knowledge in a decision (patterns, algorithms, principles and theorems)


Not all knowledge is specific to your context, a lot of knowledge is generic and shared with many other people in many other companies in the industry. Think about all the knowledge on programming languages, developers tools, software patterns and practices; most of that is industry standard, as we say.

As the State-of-the-Art is making progress, more and more of what we do everyday gets codified by talented practitioners into patterns, techniques and practices. And all that knowledge is properly documented into books, blog posts or conference talks and workshops around the world. That's Ready-Made Documentation that's readily available, for the price of a book.

Here are some random examples:
- Test-Driven Development, a design technique by Kent Beck
- The 23 Design Patterns from the Gang of Four
- Analysis Patterns, Patterns of Enterprise Application Architecture and everything written by Martin Fowler
- Domain-Driven Design by Eric Evans
- Everything on the C2 wiki
- Every book from Jerry Weinberg
- Continuous Delivery patterns by Jez Humber and Dave Farley
- All the Clean Code literature
- Git workflow strategies
- and thousands of other great content in the literature

We're pretty much in a situation where we could safely say:

> "If you can think about it, somebody has already written about it."

Patterns, standard names, standard practices exist, even if you don't know them yet. The literature is still growing and so huge that you cannot know it all, or you would spend so much time reading you would not have any time left to create any software.

Knowledge about mature sectors of the business industries is also generic knowledge. Even in very competitive areas like Pricing in finance or Supply Chain Optimization in e-commerce, most of the knowledge is public and available in industry-standard books, and only a small part of the business is specific and confidential for a while.

Examples: essential reading lists by business domain, with books often referred to as "The Bible of the field": Options, Futures, and Other Derivatives (9th Edition) by John C Hull, Logistics and Supply Chain Management (4th Edition) by Martin Christopher etc.

The good news is that generic knowledge is already documented in the industry literature. There are books, blog posts, conference talks that describe it quite well. There are standard vocabularies to talk about it. There are trainings available to learn it faster with knowledgable people.

Generic knowledge is basically a solved problem. This knowledge is ready-made, ready to be reused by everyone. When you use it, you just have to link to an authoritative source and you're done documenting.

**Therefore: Consider that most knowledge is already documented somewhere in the industry literature. Do your homework and look for the standard source of knowledge, on the web or by asking other knowledgeable people. Don't try to document again something that's been already well-written by someone else, link to it instead. And don't try to be original, instead adopt the standard practices and the standard vocabulary as much as possible.**

In most cases, being conformist by deliberately adopting industry standards is a win. What you're doing is almost certainly already covered somewhere. If you're unlucky it will be only in a blog or two. If you're lucky it's industry standard without you knowing. Either way, you want to find where it is covered, for several reasons:

- You can refer to them instead of doing yourself the writing
- They may suggest improvements or alternatives you haven't considered
- They may describe the situation in a more deeper way than you did, giving you external insights
- The description validates that your approach makes sense. If you cannot find any account, beware.
- Most importantly, this will tell you how the rest of the planet talks about this situation.

## The power of a standard vocabulary

> He who controls vocabulary controls thought
> -- Wittgenstein

Talking the same words as everybody on the planet is a fantastic advantage. You can now talk with shorter sentences. You could spend several sentence trying to describe the design of a text editor:

> Inline editing is done thanks to a an interface with several subclasses. The text editor delegates the actual processing to the interface, without having to care which subclass is actually doing the job. Depending on whether the inline editing is on or off, an instance of a different subclass is used.

However if you're familiar with ready-made documented knowledge like design patterns, then:

> Code written according to a consistent and shared pattern language can be described more concisely. "Inline editing is implemented as a State of the Controller" --if you know the vocabulary, you know what you'll find when you look at the code.
> -- Kent Beck https://www.facebook.com/notes/kent-beck/entropy-as-understood-by-a-programmer-part-1-program-structure/695263730506494

Each mature industry has its own rich jargon because it's efficient to communicate. Every part in a car has its specific name depending on its role in the vehicle: s shaft is not just shaft, it's a *camshaft*, or a *crankshaft*. There's a *piston* in a *cylinder*, *pushrods*, and a *timing chain*. Domain-Driven Design advocates to carefully grow such a Ubiquitous Language of the domain.

Our industry makes progress each time its standard vocabulary grows, for example whenever Martin Fowler coins another name for a patterns that we do without thinking about it. This process is in fact a process of growing our own Ubiquitous Language for our industry.

T> In the book *Software Craftsmanship Apprenticeship Patterns*, Dave Hoover and Adewale Oshineye advocate "Study The Classics".

As a result, if you know what you're doing and you know how it's called in the industry, just insert a reference to the industry standard and you have achieved extensive documentation at low cost.

Patterns and pattern languages are particularly effective ways to pack ready-made knowledge in a reusable documentation. Patterns really are *canned documentation*. They create a standard vocabulary one can use, and refer to for complete reference.

> Design patterns are communication tools for experienced programmers. Not training wheels or scaffolding for beginners.
> -- @nycplayer on Twitter

A> Patterns matter. But when I started leaning about design patterns, I was trying to use them whenever I could. Its so common that some even call that *patternitis*. Then I became reasonable and learnt when not to use them.
A>
A> Many article have expressed harsh criticism about having the code full of patterns; however I think they miss the point: you should learn as many patterns as you can. The point is not to learn patterns in order to use them, though it can be useful, but the point is to know many patterns in order to know the standard name of what you're already doing. In this view 100% of the code could, and perhaps should, be described by the means of patterns.

Knowing the standard vocabulary also opens the door to even more knowledge: you can find books and buy training on the right topic you're interested in. You can also pinpoint people with this knowledge to hire them.

It's not so much about finding a solution. Even when you have a perfect solution it's worth finding how it's called in the industry. This way you can just refer to the work of other people who describe the solution in a well-written, peer-reviewed and time-reviewed fashion.

## Link to standard knowledge

Generic knowledge is already documented in the industry literature, in books or online. When you use it, link to the authoritative source, with an Internet link or a bibliographic reference. It has been written well once, refer to it rather than redoing a poorer job of documenting it again.

Of course the biggest problem is to identify the standard name for a piece of knowledge.

## Searching for the reference

Search engines like Google, or community websites like C2 or Stack Overflow are your friends there. You have to start by trying to guess how other talk about a topic. Then you can quickly scan the first results from the search engine to find out a more accurate vocabulary which in turn helps make narrower queries. Through this exploration you'll quickly learn a lot and get to see how much of the topic is already codified, and under what names.

Don't hesitate to ask around for suggestions, in your team or on a forum. Their experience and seniority of other people helps as they had more time to index more pointers to standard knowledge they've encountered, even superficially, over the years.

From a given term, you can also browse Wikipedia and all the various links at the end of the articles. Keep an eye on the bottom "related" links as well, until you recognize your situation. Wikipedia is a fantastic tool to map a standard vocabulary to your own mental universe.


## More than just vocabulary

A shared standard vocabulary is the key advantage to communicate effectively, in conversations and in writing. That said, once you've found a standard description, it often comes with refinements and alternatives you haven't considered. This is useful too. Ready-made documentation is in fact reusable thinking, which is a great help. It's a bit like having the author, usually a seasoned practitioner, close to you to think together. Whenever you read on a standard solution, process, pattern or approach, the secret sauce is suggested by @michelesliger on Twitter:

> YOU STILL HAVE TO THINK. BUT YOU DONT HAVE TO DO IT ALONE.

When we say that "we create an Adapter on top of the legacy subsystem", this sentence implies a lot of things in a few words, because there's more than a name in the idea of the Adapter pattern. For example, an important consequence in this pattern is that the adaptee, the legacy subsystem in our example, should not know about the Adapter, only the Adapter should know about the legacy subsystem.

When we say that this package represents the Presentation Layer whereas this other package represents the Domain Layer, we also imply that only the former can depend on the latter, never the other way round.

It's the norm in mathematics to reuse theorems and shared abstract structures from the literature to go further without re-inventing and having to prove the same results again and again. It's not just about the vocabulary.
