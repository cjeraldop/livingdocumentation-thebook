# Context Diagram

*Showing how a system is integrated to surrounding actors*

No system is an island, every system is part of a bigger eco-system with other actors, typically people and other systems. From a developer point of view, the integration to other systems is sometime considered obvious knowledge not worth documenting, especially in the early years of a system. But after a while the system has grown and is now deeply integrated with many other actors, and even people in the team no longer know about this ecosystem. To reconstitute the whole picture you'll now have to review all the code manually and interview knowledgeable people, where "knowledgeable" is also synonymous with "busy".

This context knowledge is essential to reason about impacts to or from other actors when considering changes in this system or in another external system.

As such it deserves to be made clearly visible, up-to-date at any time.

Basically an context diagram is about a recap of all actors using the system (API side) or used by the system (Service Providers side):

      Actors using     * --> System --> *   Actors used
      using the system                     by the system

The context can be expressed as a simple list:

API (actors using the system)

 - Fuelo Card API
 - Fleet Management Teams
 - Support & Monitoring

SPI (actors providing services to the system)

 - Google Geocoding
 - GPS Tracking from Garmin
 - Legacy Vehicle Assignment

But a visual layout has its advantages too:

![A generated context diagram with 3 actors on the left and 3 actors on the right](images/system_diagram_flottio.png)

You can create such diagram by hand each time you need it. It will be tailored for your matter at hand. Or you could generate it.

The above diagram was generated from the sample *Flottio* fleet management used throughout this book.

A> The name 'context diagram' is borrowed from Simon Brown [C4 Model](http://www.codingthearchitecture.com/2014/08/24/c4_model_poster.html), a lightweight approach to architecture diagrams which is becoming increasingly popular among developers.

This diagram tells the story of the system through its links to external actors, with some brief descriptions on some of them.

This diagram is a **Living Document**, refreshed whenever the system changes, automatically. As any living diagram, it is generated by scanning the augmented source code and calling a graph layout engine like *GraphViz*. If we were to add or delete a new module, the diagram would adjust as quickly as the next build. It is also an example of a **Refactoring-proof Diagram**; if we just want to rename a module in the code, the diagram will be renamed too without extra effort. No need to fire PowerPoint or a diagram editor each time.

## Hyperlinks to the corresponding source code location

As opposed to a manually created diagram, a it can feature hyperlinks to the accurate locations in the code base. Click on any external actor on the diagram to jump to the corresponding URL in the source code repository online.

Note that even without a link, the wording in the diagram can be used verbatim to perform a search in the code base. Since the wording came from the code, it would be easy to find the corresponding location.

## Augmented Code & Knowledge Consolidation

The problem, of course, is to identify automatically the external actors, their name, description and direction of use (using or being used). Unfortunately I haven't found a miracle solution for that.

To generate this diagram, the code had to be augmented with some annotations to declare the *external actor*. This is an example of **Augmented Code** and is also a case of **Consolidation** of information spread across multiple packages and sub-packages.

For example this package `flottio.fuelcardmonitoring.legacy` which takes care of the integration with the legacy system for vehicle assignments to drivers, a provider of services for the system under consideration:

~~~~~~~~
/**
 * Vehicle Management is a legacy system which manages which drivers is associated to a vehicle for a period of time.
 */
@ExternalActor(
   name = "Legacy Vehicle Assignment System",
   type = SYSTEM,
   direction = ExternalActor.Direction.SPI)
package flottio.fuelcardmonitoring.legacy;

import static flottio.annotations.ExternalActor.ActorType.SYSTEM;
import flottio.annotations.ExternalActor;
~~~~~~~~

Another example is the class listening to the incoming message bus, which basically uses the system to check if fuel card transactions have anomalies:

~~~~~~~~
package flottio.fuelcardmonitoring.infra;
   // more imports...

/**
 * Listens to incoming fuel card transactions from the external system of the Fuel Card Provider
 */
@ExternalActor(
   name = "Fuelo Fuel Card Provider",
   type = SYSTEM,
   direction = Direction.API)
public class FuelCardTxListener {
   //...
~~~~~~~~

We don't have to use annotations. We could also add sidecar files in the same folder than the annotation code, with the same content than the annotation inside, as Yaml, Json or as a .ini file:

~~~~~~~~
; external-port.ini
; this sidecar file is in the integration code folder
name=Fuelo Fuel Card Provider
type=SYSTEM
direction=API
~~~~~~~~


Some time later we want to add information to the context diagram, so we add this information to the code itself, in the Javadoc of the integration code, and then the diagram gets updated:

![A generated context diagram with 3 actors on the left and 3 actors on the right](images/system_diagram_flottio2.png)

## Limitations & Benefits

Because of the need for some code augmentation with annotations or sidecar files, there remains the risk of not knowing about some external actors.

If in your project you can enumerate the few only possible ways perform integration, you may try to detect them all and add them to the diagram unless silenced explicitly through code augmentation.

In any case, integration through the database will be hard to detect and document. You may believe the database is a private detail of your system, but if another system queries or writes into it directly, it will be hard to find out without a conversation with the culprits.

On the other hand, this diagram shows every possible integration, but it cannot tell if they are active in production or not. If the code base is a toolkit for a product line, it will show all the potential integrations, not the one actually used in practice in a particular instance.

Another drawback of a generated diagram like the above compared to a ad hoc manual diagram is that they are not tailored for the particular matter of the day. But they're also much faster to produce.

Still, you may want to tweak the diagram generator, for example to focus on a subset of the context.
