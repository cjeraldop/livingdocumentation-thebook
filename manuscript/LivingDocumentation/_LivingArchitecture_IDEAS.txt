## SLA/Test-Driven Architecture for *-ilities:

- actual tests e.g. load, scaling, times, idempotence, data consistency... e.g. Threshold Tests may document some of the expected performance criteria.
- tests documented as scenarios in the BDD / Living Documentation suite
- external tools and their config documented as scenarios in the BDD / Living Documentation suite: e.g. pen tests, accessibility tests
- static analysis tools along with their acceptance criteria: security, bugs, style violations, metrics thresholds
- manual tests: usability...
- monitoring rollback thresholds: conversion rate, response time, CPU consumption...
- prose for other objectives, e.g. financials, satisfaction expectations etc.

> @fchabanois: pour garder une trace et prévoir ses expériences sur le produit (et les succès + failures) https://t.co/y6ir9TeW5m #startup #hypotheses

With distributed systems all the above can be done at the component level or at the level of a collection of components, which complicates the matter.

--


## Commit Messages

@MattRussellUK: The Queen's speech is like the release notes for a minor new version of the UK

## Tracing Bullets of Flow?

## No Comment Needed
Avoid traps. Make unbreakable API's. No need for troubleshooting sections. Car no longer have maintenance manuals, they offer auto-diagnosis instead, embedded into your dashboard. Minimal surface over a larger volume...

## Declarative Automation
automation and documentation at the same time, as in BDD or infra as code.



## Enforced Architecture
A special case of Declarative Automation, where the architecture is considered as a set of constraints to enforce through automated checks and metrics. All these constraints should be declarative.

> Picture: cop going to fine the coder

## Explicit Declarative Alignment (Knowledge Level)
- Declare the meta model of the business domain, and have each component declare it is strictly aligned with one particular element, or not well aligned because it maps partially to several elements.


Transparent Architecture -> decentralize architecture and decision making

What business area and function (features?) does an application implement? Declare that explicitly, if possible in the source code itself.

Golden source for each aggregate: what application / schema is the one source of truth / master data for a given concept? Glossary of golden sources. Sometimes it's mixed between applications and depending on the status of the things...

SLA: by application? By business area / function? As tests? By Bounded Context? Make the. Explicit somewhere anyway.

Codex of principles. Company-wide guidelines, if any. Business strategy (automate more! Stp ratio++! Customer convenience first!), architectural strategy (decommission VB6 or J2EE, web-first). How and where to materialize that? As an Evergreen document, plus saved searches, saved monitoring configs... As a bunch info Json files with links? In a wiki, with pictures? As a slide deck for humans? Plus tools to scan the code base and report data. ASCIIdoc?

## Stable Contours
Example: "everything about tax rates and how to apply them, in the context of selling to customers"

## Cohesive Partitions / Areas
by Bounded Context by domain / SLA / Aggregate, idea target for consistent documentation.
Examples of large-scale architecture: e-commerce of cultural products and related consumer electronic products: functions x contexts x product ranges x customer segments. The same architecture analysis can be done at a large IS or a for just a big monolithic ERP (legacy superimposed structure).

## Code is its own documentation example:

@WoodyZuill: You can't fix code problems with comments, but you can sure make them worse! #CommentsOnlyWhenThereIsNoBetterWayAndEvenThenBeCautious

@dahankzter: @WoodyZuill like fixing poor usability with documentation

@pcalcado: RT @extempore2: Arbitrary abbreviations exert an ongoing low-level mental tax. The accumulation […] is much of why programming is hard.

- Supermarket pricing: literally "what's best for the customer"
- Ubiquitous Language directly in code, signal to noise ratio
- composed methods of similar level of abstraction: grand total calculation in mixed currencies
- Ward pattern of systematic behavior & total functions: encapsulate the variety of corner cases inside the objects so that the behavior is obvious from the outside
- Fluent style: example in test data builders with predefined default arrangements that are overridden when necessary: use them to report the default arrangements into the website
- Maths structures: monoids...
- Literally graphical (grid as matrix...)
- toString(), pretty printer to render compilation AST
- Literate programming

### Meaningless Behavior (Ward)
### DSL (Systematic Combinations)
### Little Arithmetic (monoid, space vectors etc)
### Explained Result (value + full traceability included)

### Documenting Dependencies

Nuget manifest as bill of material


Dependencies management (Maven, Ivy, Nuget...) is useful documentation
-> manifest files as bill of material. It tells the required nterfaces and the particular chosen implementations
-> cascaded build config
=> may be used to extract module-level consolidated dependencies diagrams for review



### Human-Friendly Technologies
REST + xHTML (human & robot) over   heavyweight we services, plain text over binary, self-descriptive over separate documentation, pretty printed over random formatting, no abbreviation, standard mime type over custom ones, runtime retention of annotations (all that unless requires otherwise of course)


## Generated diagrams

@nathanmarz: Why do so many engineers think complicated system diagrams are impressive? What's truly impressive are simple solutions to hard problems.

@pavlobaron: @nathanmarz @sbtourist the ultimate rule of thumb: if there is at least one line crossing another in a diagram,the system is too complicated

### Ecosystem views
Context (Ecosystem) diagram - TODO See Simon Brown book/blog

### Business Map
Business map of groups of concepts with relationships between them -> Derive permissible dependencies

@DomainConcept(BusinessDomain.PreTrade)
@Concern(Realtime, Critical, HighAvailability)

Or better: BoundedContext(domain = BusinessDomain.PreTrade, concerns = Realtime, Critical, HighAvailability)

Automatically generate diagrams from that. Layout based on constraints and relationships between the respective domains.

### Protocols of Interactions

Showing Model Responses
Typical object collaboration diagrams look either deceptively simple or overly complex. They don't reflect the thought or effort that went into producing them. In order to understand their significance, it is necessary to know what are key objects and what level of detail the designer intended to model. To find this information, either we need to look at supporting documents such as emerging class designs, prior conversations, and other supporting evidence. Designers can also help by walking others through their design. Diagrams alone can't show the significance of key design decisions. This is hard to find in class specifications, too. That's why designers need to tell us what they thought important.

The Art of Designing Meaningful Conversations
Reprinted from the Feb 1994 issue of The Smalltalk Report Vol. 3, No. 5
By: Rebecca J. Wirfs-Brock


### Misc
Fred George on the high freq loop on Kafka and it's rivers etc -> can describe the whole architecture in less than one hour: GOOD!

Want better documentation? Simplify and structure your design to make it possible! Make it visible, make it feedback-prone
-

Coding style and Design patterns consistency within areas: keep a mostly consistent style. By declaring the patterns used, one may create metrics to measure the deliberativeness of the code, and at the same time the consistency level of the code.

A list of architectural styles (I think most of them are caricatures, but that's what most people have in mind when they make architectural decisions)

·  Client/Server Architectural Style (deployment)
·  Component-Based Architectural Style (structure)
·  Domain Driven Design Architectural Style (domain)
·  Layered Architectural Style (structure)
·  Message-bus Architectural Style (communication)
·  N-Tier / 3-Tier Architectural Style (deployment)
·  Object-Oriented Architectural Style (structure)
·  Service-Oriented Architectural Style (communication)
·  Micro-Services (communication)

[One style may be nested within an element of another]

From http://msdn.microsoft.com/en-us/library/ee658117.aspx

Highlight the contracts between components and make them formal

Identify and write somewhere the overview in terms of:

- Inputs and Outputs
- Key Scenarios
- Key Stakes (domain, quality attributes, UX, business)

--

"Do style guides help? Eg android style code from Google."


%% project management. The goal is to reach a desired system state
%% single root, or doc
%% different modules, each with its own arch declaration






Transparent Architecture -> decentralize architecture and decision making
Metaphors & architectural patterns: pipeline, blackboard...
Word Cloud: code, scenarios; clustering?

Application B owns the concept X, and is the authoritative source for it. Other UI may call it to write X. Other systems can subscribe to changes of X, through a feed of events.

ES example of BDD documentation: Documenting behavior with Domain Events: given events, when command, then events

--
Documentation Strategy (Landscape) Arc42, C4
--

Living Context Map Diagram (TODO CODE?)

Documenting a Knowledge Level

Documenting SLA: enunciation, and tests

Creating your own annotations: Conventions, Policy, BusinessRule, Key, Monoid (bonus)
Create your own ready-made knowledge (a good way to challenge if it’s really new)


But also

Arbitrary upfront
JIT

## Codex
Coding style / paradigm & idioms (default style of design decisions)


---

Hard to change: Everything with a deep investment on: programming language, lock-I'm technology, framework and dependencies spread everywhere... Lost business rules, lack of testability: ironically there are things that are hard to change precisely because of lost knowledge.

That everybody should know: same, plus a focus on the primary concepts and large-scale structures. What you need to know also in order to protect or improve the capacity of the system to be easy to change.

@adampknight: Are 'non-functional requirements' named such because that's what how your software ends up if you ignore them? #testing

"Visible, legible and coherent to the business" Cyrille Dupuy Dauby

@mittie: Architecture should not be defined but rather discovered, refined, evolved, and explained.
#theFirstMisconceptionAboutArchitecture

--
Context (Ecosystem) diagram -
TODO See Simon Brown book/blog
--

Examples

Business map of groups of concepts with relationships between them -> Derive permissible dependencies

@DomainConcept(BusinessDomain.PreTrade)
@Concern(Realtime, Critical, HighAvailability)

Or better: BoundedContext(domain = BusinessDomain.PreTrade, concerns = Realtime, Critical, HighAvailability)

Automatically generate diagrams from that. Layout based on constraints and relationships between the respective domains.

--

## Pre-Computer metaphor

At DDDx 2014, Greg Young in his talk suggested to ask the question: "How did they do before computers?" Businesses were certainly able to run fine long before computers, using paper, routing slips and smart business rules. All this  can certainly help make the business activity much more tangible and concrete to start with. It can also trigger ideas on how to solve hard problems with non technical solutions, with no distributed transaction and race condition arguments.

As Greg suggested too, you may go further and play a role game with pieces of paper or stickies representing messages in your system: people write on them and pass them on to other people and so on. You can simulate anomalies like lost messages by stealing a piece of paper in secret, to observe what happens, or what does not happen.


## Test-Driven Architecture (Open-Space/workshop)

It's the role of architecture to take care of the required quality attributes. These quality attributes must be primarily defined with respect to the business objectives. For example, the response time for a web pg

My questions: Is it a bad idea? Is there a need? Are all these tests only used one-off or useful over time?

[quick presentation]

Find out problems early, e.g. realistic test data (Roland)
When there is a need to change the RDBMS for political reasons, these tests can be reused for non-regression, or when we upgrade or patch the DB

It happened to a team to change from pessimistic to optimistic locking in their application; this requires some re-testing too.

Test changeability
Of course stress and performance tests are useful regularly

They can help be more aware of the architectural decisions, and who this feature is for. As such they are part of the specification efforts.

Of course they are often slow tests. Even it we should keep them does not mean we have to run them all the time. The present value of many tests is greater than their future value. The only limit is to run them often enough so that they remain in sync with the actual application.

How do you choose a framework? e.g. which ORM? which DB? which table layout? You already do something not that far from TDA: you create a script, (e.g. in PERL) to populate just one table with 10M rows, and you look for what happens when you do special operations, or you compare how it performs for various table layouts to find the best one.

These scripts are disposable, and pretty unreadable too, because they are ran only once.

If you only keep them and make them more readable, perhaps BDD-style, you can reuse them as a living documentation of the architectural decisions, to answer the questions of auditors and to justify you thought about that.

And when you say to your customer: "we run on Oracle" and they answer: "well, but we yes DB2" then you are happy to reuse your scenarios when you have to port from Oracle to DB2! This is valuable for software vendors that need their software to work for different customers, with different DBs and middleware. If you only target your own infra it is a bit less essential.

These scenarios should ideally use production data (but that's fragile so I'd better limit to just a few scenarios and not every of them). Just like every test, all-together tests lack the capability to pinpoint the problem when it happens. Separation of concerns remains paramount, and the tests must be time-independent and independent from data .

We need non-regression scenarios for performance, e.g. what happens when 1000 users book at the same time?

Think about operations earlier
Developers should write the tests and provide them to the production team. It may help them spot a lock in the DB.

What happens to these tests?
From Jenkins to Nagios
Include tools like penetration test tools as part of the suite

(were most participating: Roland, Stephan, Franck, Tilman, Patrick)

--
@TypicalStyle snippet -> to include in a document about style guidelines
--

--
Documenting unfinished work, decision points, extension points, alternatives and assumptions

Threshold Tests
Tags @ Linked Tags

--
Application, toolkit or framework? Often a bit of all.
-> You don't document each part the same way.

Applications define everything down to the exact requires behaviors. The scenarios are the real ones.

Toolkit and frameworks offer a set of potential building blocks that can be assembled or extended in many ways for multiple purposes. You can at best propose typical samples of use. For a given need it is common to not need all the code that comes with the toolkit or framework.

For a given deployment you provide specific wiring and configuration to instantiate the concrete application. This is typically managed by Infrastructure as Code.

--
Documentation segregated between side effect-free stuff vs side-effect stuff (Tetris in Clojure)

--- box---
## Enforced Architecture

Architecture is a lot about self-imposed constraints:
restricted dependencies
segregation of elements by chosen criteria
hygiene rules and guidelines
chosen architectural styles...

You can spend time documenting all that in guide books and prescriptive documents. Or you can try to enforce them automatically. For example during the builds you can verify that the code satisfies the hexagonal architecture, using tests or assertions at runtime.

It's interesting to notice that this is often only possible provided that your code is well-annotated.

@ericlemerdy: To respect the Acyclic Dependencies Principle : have only one package

Doing some extra work everywhere is good business when it can pay off many times. Annotations of the code to make it explicit to machines is often good business when it enables other good things, including the automated enforcement of the constraints of the architecture.
---/box---

Say no when asked for the perfect architecture. Don't over-commit

World map to share mental map and reasoning.



Optimize for flexibility and macro transparency

Conviction over truth (?)

Visualization guidelines:
- Make symmetries obvious: manual vs automatic, do nothing vs do something, single vs plural, same intent beyond variety, orthogonal stuff
- equivalence as--whole: user + UI + daemon = automated consumer
- no more than 7 things on one page
- layout matters: proximity, boundaries, left-right, bottom-up, zoom overview-details

intrinsic tags on stuff, (intensional) dynamic filtering

Prioritize by audience (dynamic filtering)

--

## Layered app in .Net

A typical architecture for .Net applications is the [Layered Application](https://msdn.microsoft.com/en-us/library/ee658109.aspx#Step4)

The key to Layered Application is dependency management. Components in one layer can interact only with peers in the same level or components from lower levels, as in [Frank Buschmann](Pattern-Oriented Software Architecture, Patterns for Concurrent and Networked Objects, Volume 2). This helps bring some structure and reduce the dependencies between components on different levels. Layering can be strict: dependencies only allowed to the layer directly below) or relaxed: dependencies allowed to any layer below.

Depending on the age of your application, you would have gone for a 3 layers architecture: presentation, business and data, or you would go for a 4 layers architecture today: presentation, services, business, data. Note that the layers can be collapsed in case one is almost empty.

The presentation layer contains everything UI for smart client interaction or browser-based interaction. The business layer is all about functionalities, workflow, calculations and representing the business domain. The data layer provides access to external systems such as databases, mainframes or external web-services.

By convention in .Net, the layered are represented by sub-projects and namespaces.
