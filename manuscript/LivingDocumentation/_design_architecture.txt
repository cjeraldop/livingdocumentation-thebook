# Documenting Design & Architecture

@mittie: Architecture should not be defined but rather discovered, refined, evolved, and explained.
#theFirstMisconceptionAboutArchitecture

#insightful #critique

When implementation starts, regularly visualize the architecture as the software changes. Get a feel for how close your implemented architecture is to your architectural vision, maybe you need to change the latter.
Compare the architecture as-implemented to your architecture as-intended to see how they differ. With automated support this can be done as part of the software build. This step does rely on you at least having some vision of what your intended architecture is. If you don't have this then you can gradually reverse engineer it from your architecture as-implemented. There are now many tools from very basic free ones through to very advanced commercial tools that can help with architecture visualization and checking.

Why does the project use this particular heavyweight technology? Hopefully it was chosen because of some requirements, following some evaluation. Who remembers that? Now that the works has changed could you switch to something simpler?

What do you talk about during meetings with the stakeholders? From inception meetings to sprint planning meetings and other impromptu meetings, a lot of concepts, thinking and decisions are taken. What happens to all this knowledge?

Sometime it only survives in the mind of the attendees. Sometime it is quickly written as minutes of the meeting and sent by email. Sometime a snapshot of the whiteboard is taken and shared. Some put everything into the tracker tool, or in their wiki.

One common problem in all these cases is that this knowledge lacks structure in the way it is organized. Given a new piece of knowledge, where should it be added?


> Technology is about tradeoffs and choices @simonbrown from Twitter

## Rationale First / Documenting design and the decisions that make it this way

Why does the project use this particular heavyweight technology? Hopefully it was chosen because of some requirements, following some evaluation. Who remembers that? Now that the works has changed could you switch to something simpler?
-
What do you talk about during meetings with the stakeholders? From inception meetings to sprint planning meetings and other impromptu meetings, a lot of concepts, thinking and decisions are taken. What happens to all this knowledge?

Sometime it only survives in the mind of the attendees. Sometime it is quickly written as minutes of the meeting and sent by email. Sometime a snapshot of the whiteboard is taken and shared. Some put everything into the tracker tool, or in their wiki.

One common problem in all these cases is that this knowledge lacks structure in the way it is organized.

Given a new piece of knowledge, where should it be added?

Architecture has a fundamental focus on communication.

## Commit Messages

@MattRussellUK: The Queen's speech is like the release notes for a minor new version of the UK

## Tracing Bullets of Flow?

## No Comment Needed
Avoid traps. Make unbreakable API's. No need for troubleshooting sections. Car no longer have maintenance manuals, they offer auto-diagnosis instead, embedded into your dashboard. Minimal surface over a larger volume...

## Declarative Automation
automation and documentation at the same time, as in BDD or infra as code.



## Enforced Architecture
A special case of Declarative Automation, where the architecture is considered as a set of constraints to enforce through automated checks and metrics. All these constraints should be declarative.

> Picture: cop going to fine the coder

## Explicit Declarative Alignment (Knowledge Level)
- Declare the meta model of the business domain, and have each component declare it is strictly aligned with one particular element, or not well aligned because it maps partially to several elements.


Transparent Architecture -> decentralize architecture and decision making

What business area and function (features?) does an application implement? Declare that explicitly, if possible in the source code itself.

Golden source for each aggregate: what application / schema is the one source of truth / master data for a given concept? Glossary of golden sources. Sometimes it's mixed between applications and depending on the status of the things...

SLA: by application? By business area / function? As tests? By Bounded Context? Make the. Explicit somewhere anyway.

Codex of principles. Company-wide guidelines, if any. Business strategy (automate more! Stp ratio++! Customer convenience first!), architectural strategy (decommission VB6 or J2EE, web-first). How and where to materialize that? As an Evergreen document, plus saved searches, saved monitoring configs... As a bunch info Json files with links? In a wiki, with pictures? As a slide deck for humans? Plus tools to scan the code base and report data. ASCIIdoc?

## Stable Contours
Example: "everything about tax rates and how to apply them, in the context of selling to customers"

## Cohesive Partitions / Areas
by Bounded Context by domain / SLA / Aggregate, idea target for consistent documentation.
Examples of large-scale architecture: e-commerce of cultural products and related consumer electronic products: functions x contexts x product ranges x customer segments. The same architecture analysis can be done at a large IS or a for just a big monolithic ERP (legacy superimposed structure).

## Code is its own documentation example:

@WoodyZuill: You can't fix code problems with comments, but you can sure make them worse! #CommentsOnlyWhenThereIsNoBetterWayAndEvenThenBeCautious

@dahankzter: @WoodyZuill like fixing poor usability with documentation

@pcalcado: RT @extempore2: Arbitrary abbreviations exert an ongoing low-level mental tax. The accumulation […] is much of why programming is hard.

- Supermarket pricing: literally "what's best for the customer"
- Ubiquitous Language directly in code, signal to noise ratio
- composed methods of similar level of abstraction: grand total calculation in mixed currencies
- Ward pattern of systematic behavior & total functions: encapsulate the variety of corner cases inside the objects so that the behavior is obvious from the outside
- Fluent style: example in test data builders with predefined default arrangements that are overridden when necessary: use them to report the default arrangements into the website
- Maths structures: monoids...
- Literally graphical (grid as matrix...)
- toString(), pretty printer to render compilation AST
- Literate programming

### Meaningless Behavior (Ward)
### DSL (Systematic Combinations)
### Little Arithmetic (monoid, space vectors etc)
### Explained Result (value + full traceability included)

### Documenting Dependencies

Nuget manifest as bill of material


Dependencies management (Maven, Ivy, Nuget...) is useful documentation
-> manifest files as bill of material. It tells the required nterfaces and the particular chosen implementations
-> cascaded build config
=> may be used to extract module-level consolidated dependencies diagrams for review



### Human-Friendly Technologies
REST + xHTML (human & robot) over   heavyweight we services, plain text over binary, self-descriptive over separate documentation, pretty printed over random formatting, no abbreviation, standard mime type over custom ones, runtime retention of annotations (all that unless requires otherwise of course)


## Generated diagrams

@nathanmarz: Why do so many engineers think complicated system diagrams are impressive? What's truly impressive are simple solutions to hard problems.

@pavlobaron: @nathanmarz @sbtourist the ultimate rule of thumb: if there is at least one line crossing another in a diagram,the system is too complicated

### Ecosystem views
Context (Ecosystem) diagram - TODO See Simon Brown book/blog

### Business Map
Business map of groups of concepts with relationships between them -> Derive permissible dependencies

@DomainConcept(BusinessDomain.PreTrade)
@Concern(Realtime, Critical, HighAvailability)

Or better: BoundedContext(domain = BusinessDomain.PreTrade, concerns = Realtime, Critical, HighAvailability)

Automatically generate diagrams from that. Layout based on constraints and relationships between the respective domains.

### Protocols of Interactions

Showing Model Responses
Typical object collaboration diagrams look either deceptively simple or overly complex. They don't reflect the thought or effort that went into producing them. In order to understand their significance, it is necessary to know what are key objects and what level of detail the designer intended to model. To find this information, either we need to look at supporting documents such as emerging class designs, prior conversations, and other supporting evidence. Designers can also help by walking others through their design. Diagrams alone can't show the significance of key design decisions. This is hard to find in class specifications, too. That's why designers need to tell us what they thought important.

The Art of Designing Meaningful Conversations
Reprinted from the Feb 1994 issue of The Smalltalk Report Vol. 3, No. 5
By: Rebecca J. Wirfs-Brock


### Misc
Fred George on the high freq loop on Kafka and it's rivers etc -> can describe the whole architecture in less than one hour: GOOD!

Want better documentation? Simplify and structure your design to make it possible! Make it visible, make it feedback-prone
-

Coding style and Design patterns consistency within areas: keep a mostly consistent style. By declaring the patterns used, one may create metrics to measure the deliberativeness of the code, and at the same time the consistency level of the code.

A list of architectural styles (I think most of them are caricatures, but that's what most people have in mind when they make architectural decisions)

·  Client/Server Architectural Style (deployment)
·  Component-Based Architectural Style (structure)
·  Domain Driven Design Architectural Style (domain)
·  Layered Architectural Style (structure)
·  Message-bus Architectural Style (communication)
·  N-Tier / 3-Tier Architectural Style (deployment)
·  Object-Oriented Architectural Style (structure)
·  Service-Oriented Architectural Style (communication)
·  Micro-Services (communication)

[One style may be nested within an element of another]

From http://msdn.microsoft.com/en-us/library/ee658117.aspx

Highlight the contracts between components and make them formal

Identify and write somewhere the overview in terms of:

- Inputs and Outputs
- Key Scenarios
- Key Stakes (domain, quality attributes, UX, business)
