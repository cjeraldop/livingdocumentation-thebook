# Context Diagram

*Showing the obvious is essential*

%% TODO include the generated system diagram


Ecosystem diagram

By consolidation of several components diagrams

- Nothing to declare: it's the considered system itself
- Non-system: external systems or components, or end actors. Each can be belong to nested scopes: components of the same app, of the same department IS, of the same company IS, of a partner company, foreign system

The ecosystem diagram on a particular scope will consider everything contained as part of itself, and the rest as external

@Port(Scope.Component, Kind.System)

But what about unused ports / adapters?

No system is an island, every system is part of a bigger eco-system with other actors, typically people and other systems. This context is often considered obvious, so we do not talk much about it. However this knowledge is essential and has to be in mind of everybody on the project, so it deserves to be shown on regularly, and in particular before any conversation with a new person.

The context can be expressed as a simple list:

- API (actors using the system)
 - Fuelo Card API
 - Fleet Management Teams
 - Support & Monitoring
- SPI (actors providing services to the system)
 - Google Geocoding
 - GPS Tracking from Garmin
 - Legacy Vehicle Assignment

But a visual layout has advantages too.

Use-case context diagram derived from Cucumber, but what for?

Roles (stick people or external systems) -->* Features (boxes within the system boundary)

// could it be generated from the Cucumber feature files narratives?
System diagram
Roles * --> System

// could it be generated from the use-cases diagrams? (just by hiding the features and only keeping the system boundary)

System diagram with input / outputs
Inputs * --> System -->* Outputs

// where to find the inputs and outputs? From methods highlighted as the published API/SPI + injected collaborators? Return types = outputs? Parameter types = inputs? Some parameter types may be callbacks to actually output stuff, or to query stuff in too.

// or just declare the stuff at macro-level, either in code or as plain DSL text? But would require maintenance too.

--
First Living Diagram

This diagram is a **Living Document**, refreshed whenever the system changes, automatically. If we were to add or delete a new module, the diagram would adjust as quickly as the next build. It is also an example of a **Plain-Text Diagram**; if we just want to change a word in a sentence, we can do it simply by editing the source code. No need to fire PowerPoint or a diagram editor.

This diagram is an example of **Augmented Code** by using annotations to augment each main module with the knowledge of its corresponding business domain. This is also a case if **Consolidation** of information spread across many packages.

Finally it's a Story-Telling Diagram, that tells a story from on node to the next through links that display a brief description.
--
Logical

Class-Level: @Port (unique port name = String, mode = IN, OUT, IN_OUT)

Then by consolidation it does not work because there can be many more port potentialities than actually used for a particular instance. It would work by taking into account one particular wiring configuration, eg Spring configuration.
--

Example from the web

@ComponentInput(
description = "The frequent itemsets found by an <i>Apriori</i> module. These are ” + "the item combinations that frequently appear together in the original examples.”, name = "Frequent Item Sets”)
final static String DATA_INPUT_FREQ_ITEM_SETS = "Frequent Item Sets”;

@ComponentOutput(
description = "A representation of the association rules found and accepted by this module. ” + "This output is typically connected to a <i>Rule Visualization</i> module.”, name = "Rule Table”)
